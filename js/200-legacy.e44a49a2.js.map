{"version":3,"file":"js/200-legacy.e44a49a2.js","mappings":"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","sources":["webpack://visual-computing-workshop/./src/pages/DiffuseReflection.vue?4a72","webpack://visual-computing-workshop/src/pages/DiffuseReflection.vue","webpack://visual-computing-workshop/./src/pages/DiffuseReflection.vue?1a4f","webpack://visual-computing-workshop/./src/pages/DiffuseReflection.vue","webpack://visual-computing-workshop/./node_modules/core-js/modules/es.global-this.js","webpack://visual-computing-workshop/./node_modules/prism-es6/components/prism-glsl.js","webpack://visual-computing-workshop/./node_modules/prism-es6/components/prism-markup-templating.js"],"sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('b-container',{staticClass:\"mt-4\"},[_c('b-row',{attrs:{\"align-content\":\"center\",\"align-h\":\"center\",\"align-v\":\"center\"}},[_c('h1',{staticClass:\"mt-4\"},[_vm._v(\"Diffuse Reflection\")])]),_c('b-row',[_c('h2',{staticClass:\"mt-4\"},[_vm._v(\"Introduction\")])]),_c('b-row',{attrs:{\"align-h\":\"left\",\"align-v\":\"left\"}},[_c('p',{staticClass:\"text-justify\"},[_vm._v(\"Diffuse reflection is the reflection of light or other waves or particles from a surface such that a ray incident on the surface is scattered at many angles rather than at just one angle as in the case of specular reflection. An ideal diffuse reflecting surface is said to exhibit Lambertian reflection, meaning that there is equal luminance when viewed from all directions lying in the half-space adjacent to the surface. \")])]),_c('b-row',{attrs:{\"align-content\":\"center\",\"align-h\":\"center\",\"align-v\":\"center\"}},[_c('b-col',[_c('b-img',{staticClass:\"mt-4\",attrs:{\"thumbnail\":\"\",\"src\":\"https://upload.wikimedia.org/wikipedia/commons/b/bd/Lambert2.gif\"}})],1),_c('b-col',[_c('b-img',{staticClass:\"mt-4\",attrs:{\"thumbnail\":\"\",\"src\":\"https://media.istockphoto.com/photos/moon-in-black-and-white-picture-id1136640083?k=20&m=1136640083&s=612x612&w=0&h=uKRjHmTcoAHed696QIad3qsf2x5zIX-6G931pZ8cTJA=\"}})],1)],1),_c('b-row',[_c('h2',{staticClass:\"mt-4\"},[_vm._v(\"Literature review\")])]),_c('b-row',[_c('p',[_vm._v(\"The moon exhibits almost exclusively diffuse reflection (also called Lambertian reflection), i.e. light is reflected into all directions without specular highlights. Other examples of such materials are chalk and matte paper; in fact, any surface that appears dull and matte. \")])]),_c('b-row',[_c('p',[_vm._v(\"In the case of perfect diffuse reflection, the intensity of the observed reflected light depends on the cosine of the angle between the surface normal vector and the ray of the incoming light. As illustrated in the figure, it is common to consider normalized vectors starting in the point of a surface, where the lighting should be computed: the normalized surface normal vector \"),_c('strong',[_vm._v(\"N\")]),_vm._v(\" is orthogonal to the surface and the normalized light direction \"),_c('strong',[_vm._v(\"L\")]),_vm._v(\" points to the light source. \")])]),_c('b-row',{attrs:{\"align-content\":\"center\",\"align-h\":\"center\",\"align-v\":\"center\"}},[_c('b-col',{staticClass:\"text-center\",attrs:{\"align-self\":\"center\"}},[_c('b-img',{staticClass:\"mt-4\",staticStyle:{\"height\":\"300px\"},attrs:{\"thumbnail\":\"\",\"src\":\"https://upload.wikimedia.org/wikipedia/commons/thumb/8/82/Diffuse_Reflection_Vectors.svg/1920px-Diffuse_Reflection_Vectors.svg.png\"}})],1)],1),_c('b-row',{staticClass:\"mt-4\"},[_c('p',[_vm._v(\"For the observed diffuse reflected light \"),_c('vue-mathjax',{attrs:{\"formula\":\"$I_{diffuse}$\"}}),_vm._v(\", we need the cosine of the angle between the normalized surface normal vector N and the normalized direction to the light source \"),_c('vue-mathjax',{attrs:{\"formula\":\"$L$\"}}),_vm._v(\", which is the dot product \"),_c('vue-mathjax',{attrs:{\"formula\":\"$N \\\\cdot L$\"}})],1)]),_c('b-row',{staticClass:\"mt-4\"},[_c('b-col',[_c('vue-mathjax',{staticClass:\"mt-4 big\",attrs:{\"formula\":\"$$N \\\\cdot L = |N| |L| \\\\cos{\\\\measuredangle N, L}$$\"}})],1)],1),_c('b-row',{staticClass:\"mt-4\"},[_c('p',[_vm._v(\"If the dot product \"),_c('vue-mathjax',{attrs:{\"formula\":\"$N \\\\cdot L$\"}}),_vm._v(\" is negative, the light source is on the “wrong” side of the surface and we should set the reflection to 0. This can be achieved by using \"),_c('vue-mathjax',{attrs:{\"formula\":\"$max(0, N \\\\cdot L)$\"}}),_vm._v(\", which makes sure that the value of the dot product is clamped to 0 for negative dot products. Furthermore, the reflected light depends on the intensity of the incoming light \"),_c('vue-mathjax',{attrs:{\"formula\":\"$I_{incomming}$\"}}),_vm._v(\" and a material constant \"),_c('vue-mathjax',{attrs:{\"formula\":\"$k_{diffuse}$\"}}),_vm._v(\" for the diffuse reflection: for a black surface, the material constant \"),_c('vue-mathjax',{attrs:{\"formula\":\"$k_{diffuse}$\"}}),_vm._v(\" is 0, for a white surface it is 1. The equation for the diffuse reflected intensity is then: \")],1)]),_c('b-row',{staticClass:\"mt-4\"},[_c('b-col',[_c('vue-mathjax',{staticClass:\"mt-4 big\",attrs:{\"formula\":\"$$I_{diffuse} = I_{incomming} k_{diffuse} max(0, N \\\\cdot L)$$\"}})],1)],1),_c('b-row',[_c('h2',{staticClass:\"mt-4\"},[_vm._v(\"Methods\")])]),_c('b-row',{staticClass:\"mt-4\"},[_c('p',[_vm._v(\"Now let's see a procedure to realize this Diffuse Reflection, this procedure may be performed for every pixel in figure\")]),_c('p',[_c('ol',[_c('li',[_vm._v(\" Get the vector \"),_c('vue-mathjax',{attrs:{\"formula\":\"$N$\"}}),_vm._v(\" as the normal vector of this point to the surface. \")],1),_c('li',[_vm._v(\" Get the vector \"),_c('vue-mathjax',{attrs:{\"formula\":\"$L$\"}}),_vm._v(\" as the vector from the point to the light. \")],1),_c('li',[_vm._v(\" Normalize the vectors as \"),_c('vue-mathjax',{attrs:{\"formula\":\"$|N|$\"}}),_vm._v(\" and \"),_c('vue-mathjax',{attrs:{\"formula\":\"$|L|$\"}}),_vm._v(\". \")],1),_c('li',[_vm._v(\" Normalize the vectors as \"),_c('vue-mathjax',{attrs:{\"formula\":\"$|N|$\"}}),_vm._v(\" and \"),_c('vue-mathjax',{attrs:{\"formula\":\"$|L|$\"}}),_vm._v(\". \")],1),_c('li',[_vm._v(\" Calculate the resulting color of multiply the light color \"),_c('vue-mathjax',{attrs:{\"formula\":\"$C_{light}$\"}}),_vm._v(\" and the color of the point \"),_c('vue-mathjax',{attrs:{\"formula\":\"$C$\"}}),_vm._v(\". \")],1),_c('li',[_vm._v(\" Multiply the previus result \"),_c('vue-mathjax',{attrs:{\"formula\":\"$C_{light}C$\"}}),_vm._v(\" by the maximun between 0 and \"),_c('vue-mathjax',{attrs:{\"formula\":\"$N \\\\cdot L$\"}}),_vm._v(\". \")],1),_c('li',[_vm._v(\" The resulting color is the color of the point. \")])])])]),_c('b-row',{staticClass:\"mt-4\"},[_c('p',[_vm._v(\"Let's see an implementation of this shader using and extention of GLSL on HLSL in unity\")])]),_c('b-row',[_c('h2',{staticClass:\"mt-4\"},[_vm._v(\"Code and Results\")])]),_c('b-row',{attrs:{\"align-content\":\"center\",\"align-h\":\"center\",\"align-v\":\"center\"}},[_c('SketchUnity',{attrs:{\"dataPath\":\"scketch/Light/Build/Unity.data\",\"loaderPath\":\"scketch/Light/Build/Unity.loader.js\",\"frameworkPath\":\"scketch/Light/Build/Unity.framework.js\",\"codePath\":\"scketch/Light/Build/Unity.wasm\",\"streamingAssetsPath\":\"scketch/Light/StreamingAssets\",\"companyName\":\"Visual Computing\",\"productName\":\"Diffuse Reflection\",\"productVersion\":\"1.0\",\"width\":\"960\",\"height\":\"600\"}})],1),_c('b-row',{staticClass:\"mt-4\",attrs:{\"align-h\":\"start\",\"align-v\":\"start\"}},[_c('h3',[_vm._v(\"Source Code Unity\")])]),_c('div',[_c('code-highlight',{attrs:{\"language\":\"glsl\"}},[_c('pre',[_vm._v(\"Shader \\\"Unity Shader\\\" {\\n    Properties{\\n        _Flag(\\\"Flag\\\", Float) = 0\\n    }\\n    SubShader {\\n        Pass {\\n            Tags { \\\"LightMode\\\" = \\\"ForwardBase\\\" }\\n\\n            GLSLPROGRAM\\n\\n            uniform float _Flag;\\n            uniform mat4 _Object2World;\\n            uniform mat4 _World2Object;\\n            uniform vec4 _WorldSpaceLightPos0;\\n            uniform vec4 _LightColor0;\\n\\n            #ifdef VERTEX\\n\\n            varying vec4 color;\\n\\n            void main() {\\n                mat4 modelMatrix = _Object2World;\\n                mat4 modelMatrixInverse = _World2Object;\\n                vec3 normalDirection = normalize(vec3(vec4(gl_Normal, 0.0) * modelMatrixInverse));\\n                vec3 lightDirection = normalize(vec3(_WorldSpaceLightPos0));\\n                vec3 diffuseReflection = \\n                    vec3(_LightColor0) * \\n                    (_Flag == 1.0 ? (vec3(gl_Vertex) + vec3(0.5, 0.5, 0.5)) : vec3(0.5, 0.5, 0.5)) * \\n                    max(0.0, dot(normalDirection, lightDirection));\\n\\n                color = vec4(diffuseReflection, 1.0);\\n                gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\\n            }\\n            #endif\\n\\n            #ifdef FRAGMENT\\n\\n            varying vec4 color;\\n\\n            void main()  {\\n                gl_FragColor = color;\\n            }\\n            #endif\\n\\n            ENDGLSL\\n        }\\n    }\\n}\\n                \")])])],1),_c('b-row',[_c('h2',[_vm._v(\"Discussion\")])]),_c('b-row',[_c('p',[_vm._v(\"Diffuse reflection is only one of many illumination models that we can find, there are cases where you have non-flat surfaces, with different materials and opacities, and you can even have several lights. What we have seen in this web page is just a small glimpse of how sophisticated and complex lighting models can be.\")])]),_c('b-row',[_c('h2',[_vm._v(\"Conclusion\")])]),_c('b-row',[_c('p',[_vm._v(\"Working with lights in computer graphics requires great knowledge of how these waves behave, it is important to abstract the behavior of things to computation and in the case of lights it is something that can be easily worked with using shaders. \")])])],1)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n    <b-container class=\"mt-4\">\n        <b-row align-content=\"center\" align-h=\"center\" align-v=\"center\">\n            <h1 class=\"mt-4\">Diffuse Reflection</h1>\n        </b-row>\n        <b-row>\n            <h2 class=\"mt-4\">Introduction</h2>\n        </b-row>\n        <b-row align-h=\"left\" align-v=\"left\">\n            <p class=\"text-justify\">Diffuse reflection is the reflection of light or other waves or particles from a surface such that a ray incident on the surface is scattered at many angles rather than at just one angle as in the case of specular reflection. An ideal diffuse reflecting surface is said to exhibit Lambertian reflection, meaning that there is equal luminance when viewed from all directions lying in the half-space adjacent to the surface. </p>\n        </b-row>\n        <b-row align-content=\"center\" align-h=\"center\" align-v=\"center\">\n            <b-col>\n                <b-img thumbnail src=\"https://upload.wikimedia.org/wikipedia/commons/b/bd/Lambert2.gif\" class=\"mt-4\"/>\n            </b-col>\n            <b-col>\n                <b-img thumbnail src=\"https://media.istockphoto.com/photos/moon-in-black-and-white-picture-id1136640083?k=20&m=1136640083&s=612x612&w=0&h=uKRjHmTcoAHed696QIad3qsf2x5zIX-6G931pZ8cTJA=\" class=\"mt-4\"/>\n            </b-col>\n        </b-row>\n        <b-row>\n            <h2 class=\"mt-4\">Literature review</h2>\n        </b-row>\n        <b-row>\n            <p>The moon exhibits almost exclusively diffuse reflection (also called Lambertian reflection), i.e. light is reflected into all directions without specular highlights. Other examples of such materials are chalk and matte paper; in fact, any surface that appears dull and matte. </p>\n        </b-row>\n        <b-row>\n            <p>In the case of perfect diffuse reflection, the intensity of the observed reflected light depends on the cosine of the angle between the surface normal vector and the ray of the incoming light. As illustrated in the figure, it is common to consider normalized vectors starting in the point of a surface, where the lighting should be computed: the normalized surface normal vector <strong>N</strong> is orthogonal to the surface and the normalized light direction <strong>L</strong> points to the light source. </p>\n        </b-row>\n        <b-row align-content=\"center\" align-h=\"center\" align-v=\"center\">\n            <b-col align-self=\"center\" class=\"text-center\">\n                <b-img thumbnail style=\"height: 300px;\" src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/8/82/Diffuse_Reflection_Vectors.svg/1920px-Diffuse_Reflection_Vectors.svg.png\" class=\"mt-4\"/>\n            </b-col>\n        </b-row>\n        <b-row class=\"mt-4\">\n            <p>For the observed diffuse reflected light <vue-mathjax formula=\"$I_{diffuse}$\"/>, we need the cosine of the angle between the normalized surface normal vector N and the normalized direction to the light source <vue-mathjax formula=\"$L$\"/>, which is the dot product <vue-mathjax formula=\"$N \\cdot L$\"/></p>\n        </b-row>\n        <b-row class=\"mt-4\">\n            <b-col>\n                <vue-mathjax class=\"mt-4 big\" formula=\"$$N \\cdot L = |N| |L| \\cos{\\measuredangle N, L}$$\"/>\n            </b-col>\n        </b-row>\n        <b-row class=\"mt-4\">\n            <p>If the dot product <vue-mathjax formula=\"$N \\cdot L$\"/> is negative, the light source is on the “wrong” side of the surface and we should set the reflection to 0. This can be achieved by using <vue-mathjax formula=\"$max(0, N \\cdot L)$\"/>, which makes sure that the value of the dot product is clamped to 0 for negative dot products. Furthermore, the reflected light depends on the intensity of the incoming light <vue-mathjax formula=\"$I_{incomming}$\"/> and a material constant <vue-mathjax formula=\"$k_{diffuse}$\"/> for the diffuse reflection: for a black surface, the material constant <vue-mathjax formula=\"$k_{diffuse}$\"/> is 0, for a white surface it is 1. The equation for the diffuse reflected intensity is then: </p>\n        </b-row>\n        <b-row class=\"mt-4\">\n            <b-col>\n                <vue-mathjax class=\"mt-4 big\" formula=\"$$I_{diffuse} = I_{incomming} k_{diffuse} max(0, N \\cdot L)$$\"/>\n            </b-col>\n        </b-row>\n        <b-row>\n            <h2 class=\"mt-4\">Methods</h2>\n        </b-row>\n        <b-row class=\"mt-4\">\n            <p>Now let's see a procedure to realize this Diffuse Reflection, this procedure may be performed for every pixel in figure</p>\n            <p>\n                <ol>\n                    <li>\n                        Get the vector <vue-mathjax formula=\"$N$\"/> as the normal vector of this point to the surface.\n                    </li>\n                    <li>\n                        Get the vector <vue-mathjax formula=\"$L$\"/> as the vector from the point to the light.\n                    </li>\n                    <li>\n                        Normalize the vectors as <vue-mathjax formula=\"$|N|$\"/> and <vue-mathjax formula=\"$|L|$\"/>.\n                    </li>\n                    <li>\n                        Normalize the vectors as <vue-mathjax formula=\"$|N|$\"/> and <vue-mathjax formula=\"$|L|$\"/>.\n                    </li>\n                    <li>\n                        Calculate the resulting color of multiply the light color <vue-mathjax formula=\"$C_{light}$\"/> and the color of the point <vue-mathjax formula=\"$C$\"/>.\n                    </li>\n                    <li>\n                        Multiply the previus result <vue-mathjax formula=\"$C_{light}C$\"/> by the maximun between 0 and <vue-mathjax formula=\"$N \\cdot L$\"/>.\n                    </li>\n                    <li>\n                        The resulting color is the color of the point.\n                    </li>\n                </ol>\n            </p>\n        </b-row>\n        <b-row class=\"mt-4\">\n            <p>Let's see an implementation of this shader using and extention of GLSL on HLSL in unity</p>\n        </b-row>\n        <b-row>\n            <h2 class=\"mt-4\">Code and Results</h2>\n        </b-row>\n        <b-row align-content=\"center\" align-h=\"center\" align-v=\"center\">\n            <SketchUnity \n                dataPath=\"scketch/Light/Build/Unity.data\"\n                loaderPath=\"scketch/Light/Build/Unity.loader.js\"\n                frameworkPath=\"scketch/Light/Build/Unity.framework.js\"\n                codePath=\"scketch/Light/Build/Unity.wasm\"\n                streamingAssetsPath=\"scketch/Light/StreamingAssets\"\n                companyName=\"Visual Computing\"\n                productName=\"Diffuse Reflection\"\n                productVersion=\"1.0\"\n                width=\"960\"\n                height=\"600\"\n                />\n        </b-row>\n        <b-row align-h=\"start\" align-v=\"start\" class=\"mt-4\">\n            <h3>Source Code Unity</h3>\n        </b-row>\n        <div>\n            <code-highlight language=\"glsl\">\n                <pre>\nShader \"Unity Shader\" {\n    Properties{\n        _Flag(\"Flag\", Float) = 0\n    }\n    SubShader {\n        Pass {\n            Tags { \"LightMode\" = \"ForwardBase\" }\n\n            GLSLPROGRAM\n\n            uniform float _Flag;\n            uniform mat4 _Object2World;\n            uniform mat4 _World2Object;\n            uniform vec4 _WorldSpaceLightPos0;\n            uniform vec4 _LightColor0;\n\n            #ifdef VERTEX\n\n            varying vec4 color;\n\n            void main() {\n                mat4 modelMatrix = _Object2World;\n                mat4 modelMatrixInverse = _World2Object;\n                vec3 normalDirection = normalize(vec3(vec4(gl_Normal, 0.0) * modelMatrixInverse));\n                vec3 lightDirection = normalize(vec3(_WorldSpaceLightPos0));\n                vec3 diffuseReflection = \n                    vec3(_LightColor0) * \n                    (_Flag == 1.0 ? (vec3(gl_Vertex) + vec3(0.5, 0.5, 0.5)) : vec3(0.5, 0.5, 0.5)) * \n                    max(0.0, dot(normalDirection, lightDirection));\n\n                color = vec4(diffuseReflection, 1.0);\n                gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n            }\n            #endif\n\n            #ifdef FRAGMENT\n\n            varying vec4 color;\n\n            void main()  {\n                gl_FragColor = color;\n            }\n            #endif\n\n            ENDGLSL\n        }\n    }\n}\n                </pre>\n            </code-highlight>\n        </div>\n        <b-row>\n            <h2>Discussion</h2>\n        </b-row>\n        <b-row>\n            <p>Diffuse reflection is only one of many illumination models that we can find, there are cases where you have non-flat surfaces, with different materials and opacities, and you can even have several lights. What we have seen in this web page is just a small glimpse of how sophisticated and complex lighting models can be.</p>\n        </b-row>\n        <b-row>\n            <h2>Conclusion</h2>\n        </b-row>\n        <b-row>\n            <p>Working with lights in computer graphics requires great knowledge of how these waves behave, it is important to abstract the behavior of things to computation and in the case of lights it is something that can be easily worked with using shaders. </p>\n        </b-row>\n    </b-container>\n</template>\n\n<script>\n    import SketchUnity from '@/components/SketchUnity.vue';\n\n    import CodeHighlight from \"vue-code-highlight/src/CodeHighlight.vue\";\n    import \"vue-code-highlight/themes/duotone-sea.css\";\n    import \"vue-code-highlight/themes/window.css\";\n    import 'prism-es6/components/prism-markup-templating';\n    import 'prism-es6/components/prism-glsl';\n    import { VueMathjax } from 'vue-mathjax';\n\n    export default {\n        name: \"VisualIllusion\",\n        components: {\n            CodeHighlight,\n            'vue-mathjax': VueMathjax,\n            SketchUnity\n        },\n        data(){\n            return {\n                \n            }\n        },\n        created(){  \n            \n        }\n    };\n</script>\n\n<style scoped>\n    p, li {\n        font-size: 1.25rem;\n    }    \n    h1 {\n        font-size: 4rem;\n    }\n    .big {\n        font-size: 1.25rem;\n    }\n</style>","import mod from \"-!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40[0].rules[0].use[1]!../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./DiffuseReflection.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40[0].rules[0].use[1]!../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./DiffuseReflection.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./DiffuseReflection.vue?vue&type=template&id=2899c0a9&scoped=true&\"\nimport script from \"./DiffuseReflection.vue?vue&type=script&lang=js&\"\nexport * from \"./DiffuseReflection.vue?vue&type=script&lang=js&\"\nimport style0 from \"./DiffuseReflection.vue?vue&type=style&index=0&id=2899c0a9&scoped=true&lang=css&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"2899c0a9\",\n  null\n  \n)\n\nexport default component.exports","var $ = require('../internals/export');\nvar global = require('../internals/global');\n\n// `globalThis` object\n// https://tc39.es/ecma262/#sec-globalthis\n$({ global: true }, {\n  globalThis: global\n});\n","Prism.languages.glsl = Prism.languages.extend('clike', {\n\t'comment': [\n\t\t/\\/\\*[\\s\\S]*?\\*\\//,\n\t\t/\\/\\/(?:\\\\(?:\\r\\n|[\\s\\S])|[^\\\\\\r\\n])*/\n\t],\n\t'number': /(?:\\b0x[\\da-f]+|(?:\\b\\d+\\.?\\d*|\\B\\.\\d+)(?:e[+-]?\\d+)?)[ulf]*/i,\n\t'keyword': /\\b(?:attribute|const|uniform|varying|buffer|shared|coherent|volatile|restrict|readonly|writeonly|atomic_uint|layout|centroid|flat|smooth|noperspective|patch|sample|break|continue|do|for|while|switch|case|default|if|else|subroutine|in|out|inout|float|double|int|void|bool|true|false|invariant|precise|discard|return|d?mat[234](?:x[234])?|[ibdu]?vec[234]|uint|lowp|mediump|highp|precision|[iu]?sampler[123]D|[iu]?samplerCube|sampler[12]DShadow|samplerCubeShadow|[iu]?sampler[12]DArray|sampler[12]DArrayShadow|[iu]?sampler2DRect|sampler2DRectShadow|[iu]?samplerBuffer|[iu]?sampler2DMS(?:Array)?|[iu]?samplerCubeArray|samplerCubeArrayShadow|[iu]?image[123]D|[iu]?image2DRect|[iu]?imageCube|[iu]?imageBuffer|[iu]?image[12]DArray|[iu]?imageCubeArray|[iu]?image2DMS(?:Array)?|struct|common|partition|active|asm|class|union|enum|typedef|template|this|resource|goto|inline|noinline|public|static|extern|external|interface|long|short|half|fixed|unsigned|superp|input|output|hvec[234]|fvec[234]|sampler3DRect|filter|sizeof|cast|namespace|using)\\b/\n});\n\nPrism.languages.insertBefore('glsl', 'comment', {\n\t'preprocessor': {\n\t\tpattern: /(^[ \\t]*)#(?:(?:define|undef|if|ifdef|ifndef|else|elif|endif|error|pragma|extension|version|line)\\b)?/m,\n\t\tlookbehind: true,\n\t\talias: 'builtin'\n\t}\n});","(function (Prism) {\n\n\t/**\n\t * Returns the placeholder for the given language id and index.\n\t *\n\t * @param {string} language\n\t * @param {string|number} index\n\t * @returns {string}\n\t */\n\tfunction getPlaceholder(language, index) {\n\t\treturn '___' + language.toUpperCase() + index + '___';\n\t}\n\n\tObject.defineProperties(Prism.languages['markup-templating'] = {}, {\n\t\tbuildPlaceholders: {\n\t\t\t/**\n\t\t\t * Tokenize all inline templating expressions matching `placeholderPattern`.\n\t\t\t *\n\t\t\t * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns\n\t\t\t * `true` will be replaced.\n\t\t\t *\n\t\t\t * @param {object} env The environment of the `before-tokenize` hook.\n\t\t\t * @param {string} language The language id.\n\t\t\t * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.\n\t\t\t * @param {(match: string) => boolean} [replaceFilter]\n\t\t\t */\n\t\t\tvalue: function (env, language, placeholderPattern, replaceFilter) {\n\t\t\t\tif (env.language !== language) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar tokenStack = env.tokenStack = [];\n\n\t\t\t\tenv.code = env.code.replace(placeholderPattern, function (match) {\n\t\t\t\t\tif (typeof replaceFilter === 'function' && !replaceFilter(match)) {\n\t\t\t\t\t\treturn match;\n\t\t\t\t\t}\n\t\t\t\t\tvar i = tokenStack.length;\n\t\t\t\t\tvar placeholder;\n\n\t\t\t\t\t// Check for existing strings\n\t\t\t\t\twhile (env.code.indexOf(placeholder = getPlaceholder(language, i)) !== -1)\n\t\t\t\t\t\t++i;\n\n\t\t\t\t\t// Create a sparse array\n\t\t\t\t\ttokenStack[i] = match;\n\n\t\t\t\t\treturn placeholder;\n\t\t\t\t});\n\n\t\t\t\t// Switch the grammar to markup\n\t\t\t\tenv.grammar = Prism.languages.markup;\n\t\t\t}\n\t\t},\n\t\ttokenizePlaceholders: {\n\t\t\t/**\n\t\t\t * Replace placeholders with proper tokens after tokenizing.\n\t\t\t *\n\t\t\t * @param {object} env The environment of the `after-tokenize` hook.\n\t\t\t * @param {string} language The language id.\n\t\t\t */\n\t\t\tvalue: function (env, language) {\n\t\t\t\tif (env.language !== language || !env.tokenStack) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Switch the grammar back\n\t\t\t\tenv.grammar = Prism.languages[language];\n\n\t\t\t\tvar j = 0;\n\t\t\t\tvar keys = Object.keys(env.tokenStack);\n\n\t\t\t\tfunction walkTokens(tokens) {\n\t\t\t\t\tfor (var i = 0; i < tokens.length; i++) {\n\t\t\t\t\t\t// all placeholders are replaced already\n\t\t\t\t\t\tif (j >= keys.length) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar token = tokens[i];\n\t\t\t\t\t\tif (typeof token === 'string' || (token.content && typeof token.content === 'string')) {\n\t\t\t\t\t\t\tvar k = keys[j];\n\t\t\t\t\t\t\tvar t = env.tokenStack[k];\n\t\t\t\t\t\t\tvar s = typeof token === 'string' ? token : token.content;\n\t\t\t\t\t\t\tvar placeholder = getPlaceholder(language, k);\n\n\t\t\t\t\t\t\tvar index = s.indexOf(placeholder);\n\t\t\t\t\t\t\tif (index > -1) {\n\t\t\t\t\t\t\t\t++j;\n\n\t\t\t\t\t\t\t\tvar before = s.substring(0, index);\n\t\t\t\t\t\t\t\tvar middle = new Prism.Token(language, Prism.tokenize(t, env.grammar), 'language-' + language, t);\n\t\t\t\t\t\t\t\tvar after = s.substring(index + placeholder.length);\n\n\t\t\t\t\t\t\t\tvar replacement = [];\n\t\t\t\t\t\t\t\tif (before) {\n\t\t\t\t\t\t\t\t\treplacement.push.apply(replacement, walkTokens([before]));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treplacement.push(middle);\n\t\t\t\t\t\t\t\tif (after) {\n\t\t\t\t\t\t\t\t\treplacement.push.apply(replacement, walkTokens([after]));\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (typeof token === 'string') {\n\t\t\t\t\t\t\t\t\ttokens.splice.apply(tokens, [i, 1].concat(replacement));\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ttoken.content = replacement;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (token.content /* && typeof token.content !== 'string' */) {\n\t\t\t\t\t\t\twalkTokens(token.content);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn tokens;\n\t\t\t\t}\n\n\t\t\t\twalkTokens(env.tokens);\n\t\t\t}\n\t\t}\n\t});\n\n}(Prism));\n"],"names":["render","_vm","this","_h","$createElement","_c","_self","staticClass","attrs","_v","staticStyle","staticRenderFns","name","components","CodeHighlight","SketchUnity","component","$","global","globalThis","Prism","languages","glsl","extend","insertBefore","pattern","lookbehind","alias","getPlaceholder","language","index","toUpperCase","Object","defineProperties","buildPlaceholders","value","env","placeholderPattern","replaceFilter","tokenStack","code","replace","match","placeholder","i","length","indexOf","grammar","markup","tokenizePlaceholders","j","keys","walkTokens","tokens","token","content","k","t","s","before","substring","middle","Token","tokenize","after","replacement","push","apply","splice","concat"],"sourceRoot":""}