{"version":3,"file":"js/411-legacy.d75f37de.js","mappings":"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","sources":["webpack://visual-computing-workshop/./src/pages/Texturing.vue?5921","webpack://visual-computing-workshop/./src/sketches/uv.p5.js","webpack://visual-computing-workshop/./src/sketches/texturing.p5.js","webpack://visual-computing-workshop/src/pages/Texturing.vue","webpack://visual-computing-workshop/./src/pages/Texturing.vue?a685","webpack://visual-computing-workshop/./src/pages/Texturing.vue"],"sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('b-container',{staticClass:\"mt-4\"},[_c('b-row',{attrs:{\"align-content\":\"center\",\"align-h\":\"center\",\"align-v\":\"center\"}},[_c('h1',{staticClass:\"mt-4\"},[_vm._v(\"Texturing\")])]),_c('b-row',[_c('h2',{staticClass:\"mt-4\"},[_vm._v(\"Introduction\")])]),_c('b-row',{attrs:{\"align-h\":\"left\",\"align-v\":\"left\"}},[_c('h3',[_vm._v(\"RGB color model\")]),_c('p',{staticClass:\"text-justify\"},[_vm._v(\"The RGB color model is an additive color model in which the red, green, and blue primary colors of light are added together in various ways to reproduce a broad array of colors. The name of the model comes from the initials of the three additive primary colors, red, green, and blue. The main purpose of the RGB color model is for the sensing, representation, and display of images in electronic systems, such as televisions and computers, though it has also been used in conventional photography. Before the electronic age, the RGB color model already had a solid theory behind it, based in human perception of colors. RGB is a device-dependent color model: different devices detect or reproduce a given RGB value differently, since the color elements (such as phosphors or dyes) and their response to the individual red, green, and blue levels vary from manufacturer to manufacturer, or even in the same device over time. Thus an RGB value does not define the same color across devices without some kind of color management.\")]),_c('b-img',{attrs:{\"thumbnail\":\"\",\"center\":\"\",\"src\":\"https://upload.wikimedia.org/wikipedia/commons/thumb/a/af/RGB_color_solid_cube.png/220px-RGB_color_solid_cube.png\"}})],1),_c('b-row',{attrs:{\"align-h\":\"left\",\"align-v\":\"left\"}},[_c('h3',[_vm._v(\"Luma\")]),_c('p',{staticClass:\"text-justify\"},[_vm._v(\"In video, luma represents the brightness in an image (the \\\"black-and-white\\\" or achromatic portion of the image). Luma is typically paired with chrominance. Luma represents the achromatic image, while the chroma components represent the color information. Converting R′G′B′ sources (such as the output of a three-CCD camera) into luma and chroma allows for chroma subsampling: because human vision has finer spatial sensitivity to luminance (\\\"black and white\\\") differences than chromatic differences, video systems can store and transmit chromatic information at lower resolution, optimizing perceived detail at a particular bandwidth.\")])]),_c('b-row',{attrs:{\"align-h\":\"left\",\"align-v\":\"left\"}},[_c('h3',[_vm._v(\"HSV and HSL color models\")]),_c('p',{staticClass:\"text-justify\"},[_vm._v(\"HSL (for hue, saturation, lightness) and HSV (for hue, saturation, value; also known as HSB, for hue, saturation, brightness) are alternative representations of the RGB color model, designed in the 1970s by computer graphics researchers to more closely align with the way human vision perceives color-making attributes. In these models, colors of each hue are arranged in a radial slice, around a central axis of neutral colors which ranges from black at the bottom to white at the top. The HSL representation models the way different paints mix together to create color in the real world, with the lightness dimension resembling the varying amounts of black or white paint in the mixture (e.g. to create \\\"light red\\\", a red pigment can be mixed with white paint; this white paint corresponds to a high \\\"lightness\\\" value in the HSL representation). Fully saturated colors are placed around a circle at a lightness value of ½, with a lightness value of 0 or 1 corresponding to fully black or white, respectively.\")]),_c('b-img',{attrs:{\"thumbnail\":\"\",\"center\":\"\",\"width\":\"500\",\"src\":\"https://upload.wikimedia.org/wikipedia/commons/thumb/a/a0/Hsl-hsv_models.svg/1024px-Hsl-hsv_models.svg.png\"}})],1),_c('b-row',[_c('h2',[_vm._v(\"Results\")])]),_c('b-col',[_c('h3',[_vm._v(\"UV Visualization\")]),_c('SketchP5',{staticClass:\"mt-4\",attrs:{\"sketch\":_vm.first_sketch,\"width\":960,\"heigth\":640,\"index\":'-1'}})],1),_c('b-col',[_c('h3',[_vm._v(\"Texture Sampling\")]),_c('SketchP5',{staticClass:\"mt-4\",attrs:{\"sketch\":_vm.second_sketch,\"width\":960,\"heigth\":640,\"index\":'-2'}})],1)],1)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","/**\n * Application of Scene Tree using as input a Wacom stylus p5.js\n * @param {p5} p5 reference \n */\n\nconst sketch = (p5) => {\n    const WIDTH = 960;\n    const HEIGHT = 540;\n\n    let uvShader;\n    let type = 0;\n    let shapeType = 0;\n    let selector;\n    let shape;\n\n    p5.preload = () => {\n        //console.log(p5.texcoords2);\n        uvShader = p5.readShader('shaders/uv.frag', { matrices: p5.Tree.pMatrix | p5.Tree.mvMatrix, varyings: p5.Tree.texcoords2 });\n        \n    }\n\n    p5.setup = () => {\n        // Canvas definition\n        let canvas = p5.createCanvas(WIDTH, HEIGHT, p5.WEBGL);\n        canvas.parent(\"vue-canvas-1\");\n        p5.noStroke();\n        // see: https://p5js.org/reference/#/p5/shader\n        p5.shader(uvShader);\n        // https://p5js.org/reference/#/p5/textureMode\n        // best and simplest is to just always used NORMAL\n        p5.textureMode(p5.NORMAL);\n        selector = p5.createSelect();\n        selector.parent(\"vue-canvas-1\");\n        selector.position(100, 80);\n        selector.option(\"RG\");\n        selector.option(\"GB\");\n        selector.option(\"RB\");\n        selector.selected(\"RG\");\n        selector.changed(() => {\n            let item = selector.value();\n            if (item === \"RG\") {\n                type = 0;\n            } else if (item === \"GB\") {\n                type = 1;\n            } else if (item === \"RB\") {\n                type = 2;\n            }\n            uvShader.setUniform('type', type);\n        });\n        shape = p5.createSelect();\n        shape.parent(\"vue-canvas-1\");\n        shape.position(100, 120);\n        shape.option(\"Square\");\n        shape.option(\"Circle\");\n        shape.option(\"Triangle\");\n        shape.selected(\"Square\");\n        shape.changed(() => {\n            let item = shape.value();\n            if (item === \"Square\") {\n                shapeType = 0;\n            } else if (item === \"Circle\") {\n                shapeType = 1;\n            } else if (item === \"Triangle\") {\n                shapeType = 2;\n            }\n        })\n    }\n\n    p5.draw = () => {\n        p5.background(0);\n        // clip-space quad (i.e., both x and y vertex coordinates ∈ [-1..1])\n        // https://p5js.org/reference/#/p5/quad\n        // It's worth noting (not mentioned in the api docs) that the quad\n        // command also adds the texture coordinates to each of its vertices.\n        if (shapeType == 0) {\n            p5.quad(-WIDTH / 2, -HEIGHT / 2, WIDTH / 2, -HEIGHT / 2, WIDTH / 2, HEIGHT / 2, -WIDTH / 2, HEIGHT / 2);\n        } else if (shapeType == 1) {\n            p5.circle(0, 0, HEIGHT);\n            p5.circle(0.5, 0.5, HEIGHT);\n        } else if (shapeType == 2) {\n            // let v1 = p5.Vector.random2D();\n            // let v2 = p5.Vector.random2D();\n            // let v3 = p5.Vector.random2D();\n            p5.triangle(-WIDTH/4, HEIGHT/2, 0, -HEIGHT/2, WIDTH/4, HEIGHT/2);\n            // p5.beginShape(p5.TRIANGLES);\n            // p5.vertex(v1.x, v1.y);\n            // p5.vertex(v2.x, v2.y);\n            // p5.vertex(v3.x, v3.y);\n            // p5.endShape();\n        }\n    }\n\n}\n\nexport default sketch;\n\n","/**\n * Application of Scene Tree using as input a Wacom stylus p5.js\n * @param {p5} p5 reference \n */\n\n const sketch = (p5) => {\n    const WIDTH = 960;\n    const HEIGHT = 540;\n\n    let brightnessShader;\n    let img;\n    let type;\n    let selector;\n    let grey_scale;\n\n    p5.preload = () => {\n        brightnessShader = p5.readShader('shaders/brightness.frag', { varyings: p5.Tree.texcoords2 });\n        img = p5.loadImage('images/fire_breathing.jpg');\n    }\n\n    p5.setup = () => {\n        // Canvas definition\n        let canvas = p5.createCanvas(WIDTH, HEIGHT, p5.WEBGL);\n        canvas.parent(\"vue-canvas-2\");\n        p5.noStroke();\n        p5.shader(brightnessShader);\n        p5.textureMode(p5.NORMAL);\n        selector = p5.createSelect();\n        selector.parent(\"vue-canvas-2\");\n        selector.position(100, 120);\n        selector.option(\"Luma\");\n        selector.option(\"HSV\");\n        selector.option(\"HSL\");\n        selector.selected(\"RG\");\n        selector.changed(() => {\n            let item = selector.value();\n            if (item === \"Luma\") {\n                type = 0;\n            } else if (item === \"HSV\") {\n                type = 1;\n            } else if (item === \"HSL\") {\n                type = 2;\n            }\n            brightnessShader.setUniform('type', type);\n        });\n        grey_scale = p5.createCheckbox('Grey scale', false);\n        grey_scale.parent(\"vue-canvas-2\")\n        grey_scale.position(100, 80);\n        grey_scale.style('color', 'white');\n        grey_scale.input(() => brightnessShader.setUniform('grey_scale', grey_scale.checked()));\n        brightnessShader.setUniform('texture', img);\n    }\n\n    p5.draw = () => {\n        p5.background(0);\n        p5.quad(-WIDTH / 2, -HEIGHT / 2, WIDTH / 2, -HEIGHT / 2, WIDTH / 2, HEIGHT / 2, -WIDTH / 2, HEIGHT / 2);\n    }\n\n}\n\nexport default sketch;\n\n","<template>\n    <b-container class=\"mt-4\">\n        <b-row align-content=\"center\" align-h=\"center\" align-v=\"center\">\n            <h1 class=\"mt-4\">Texturing</h1>\n        </b-row>\n        <b-row>\n            <h2 class=\"mt-4\">Introduction</h2>\n        </b-row>\n        <b-row align-h=\"left\" align-v=\"left\">\n            <h3>RGB color model</h3>\n            <p class=\"text-justify\">The RGB color model is an additive color model in which the red, green, and blue primary colors of light are added together in various ways to reproduce a broad array of colors. The name of the model comes from the initials of the three additive primary colors, red, green, and blue.\nThe main purpose of the RGB color model is for the sensing, representation, and display of images in electronic systems, such as televisions and computers, though it has also been used in conventional photography. Before the electronic age, the RGB color model already had a solid theory behind it, based in human perception of colors.\nRGB is a device-dependent color model: different devices detect or reproduce a given RGB value differently, since the color elements (such as phosphors or dyes) and their response to the individual red, green, and blue levels vary from manufacturer to manufacturer, or even in the same device over time. Thus an RGB value does not define the same color across devices without some kind of color management.</p>\n            <b-img thumbnail center src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/a/af/RGB_color_solid_cube.png/220px-RGB_color_solid_cube.png\"></b-img>\n        </b-row>\n        <b-row align-h=\"left\" align-v=\"left\">\n            <h3>Luma</h3>\n            <p class=\"text-justify\">In video, luma represents the brightness in an image (the \"black-and-white\" or achromatic portion of the image). Luma is typically paired with chrominance. Luma represents the achromatic image, while the chroma components represent the color information. Converting R′G′B′ sources (such as the output of a three-CCD camera) into luma and chroma allows for chroma subsampling: because human vision has finer spatial sensitivity to luminance (\"black and white\") differences than chromatic differences, video systems can store and transmit chromatic information at lower resolution, optimizing perceived detail at a particular bandwidth.</p>\n        </b-row>\n        <b-row align-h=\"left\" align-v=\"left\">\n            <h3>HSV and HSL color models</h3>\n            <p class=\"text-justify\">HSL (for hue, saturation, lightness) and HSV (for hue, saturation, value; also known as HSB, for hue, saturation, brightness) are alternative representations of the RGB color model, designed in the 1970s by computer graphics researchers to more closely align with the way human vision perceives color-making attributes. In these models, colors of each hue are arranged in a radial slice, around a central axis of neutral colors which ranges from black at the bottom to white at the top.\nThe HSL representation models the way different paints mix together to create color in the real world, with the lightness dimension resembling the varying amounts of black or white paint in the mixture (e.g. to create \"light red\", a red pigment can be mixed with white paint; this white paint corresponds to a high \"lightness\" value in the HSL representation). Fully saturated colors are placed around a circle at a lightness value of ½, with a lightness value of 0 or 1 corresponding to fully black or white, respectively.</p>\n            <b-img thumbnail center width=\"500\" src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/a/a0/Hsl-hsv_models.svg/1024px-Hsl-hsv_models.svg.png\"></b-img>\n        </b-row>\n        <b-row>\n            <h2>Results</h2>\n        </b-row>\n        <b-col>\n            <h3>UV Visualization</h3>\n            <SketchP5 :sketch=\"first_sketch\" class=\"mt-4\" :width=\"960\" :heigth=\"640\" :index=\"'-1'\"/>\n        </b-col>\n        <b-col>\n            <h3>Texture Sampling</h3>\n            <SketchP5 :sketch=\"second_sketch\" class=\"mt-4\" :width=\"960\" :heigth=\"640\" :index=\"'-2'\"/>\n        </b-col>\n        <!-- <b-row>\n            <h2>Discussion</h2>\n            <p class=\"text-justify\">\n                This work applies the concept of scene trees using different devices to interact with a 3D brush (wacom tablet and webcam). The input is transformed from screen space to world space using the library p5.treegl which performs several matrices operations to achieve this result. The main idea behind this work is the relation between a 2D space with a 3D space using a third input corresponding to the z-axis which allow us tranform points coordinates depending on whether them are going to be displayed. This principle is applied in different sectors that work on computer graphics, it is common to see scene trees implemented in such a way that they are both time and memory efficient.\n            </p>\n        </b-row>\n        <b-row>\n            <h2>Conclusion</h2>\n            <ul>\n                <li>Scene trees are a important data structure that allow tranform operations between different spaces using matrices operations.</li>\n                <li>Scene trees are applied in several fields, especially in game development where characters interact in different worlds that have multiple objects contributing across different perspectives.</li>\n                <li>Scene trees recreate the geometry of the real world by abstracting the actors to objects with perspective properties and attributes.</li>\n            </ul>\n        </b-row> -->\n    </b-container>\n</template>\n\n<script>\n    import uv from '../sketches/uv.p5';\n    import texturing from '../sketches/texturing.p5';\n    import SketchP5 from '../components/SketchP5.vue';\n\n    // import CodeHighlight from \"vue-code-highlight/src/CodeHighlight.vue\";\n    import \"vue-code-highlight/themes/duotone-sea.css\";\n    import \"vue-code-highlight/themes/window.css\";\n\n    export default {\n        name: \"VisualIllusion\",\n        components: {\n            SketchP5,\n            // CodeHighlight\n        },\n        data(){\n            return {\n                stroke: true,\n                grid: true,\n                antialiasing: true,\n                first_sketch: uv,\n                second_sketch: texturing\n            }\n        },\n        created(){  \n            \n        }\n    };\n</script>\n\n<style scoped>\n    p, li {\n        font-size: 1.25rem;\n    }    \n    h1 {\n        font-size: 4rem;\n    }\n</style>","import mod from \"-!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40[0].rules[0].use[1]!../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Texturing.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40[0].rules[0].use[1]!../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Texturing.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./Texturing.vue?vue&type=template&id=2cfc1d8d&scoped=true&\"\nimport script from \"./Texturing.vue?vue&type=script&lang=js&\"\nexport * from \"./Texturing.vue?vue&type=script&lang=js&\"\nimport style0 from \"./Texturing.vue?vue&type=style&index=0&id=2cfc1d8d&scoped=true&lang=css&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"2cfc1d8d\",\n  null\n  \n)\n\nexport default component.exports"],"names":["render","_vm","this","_h","$createElement","_c","_self","staticClass","attrs","_v","first_sketch","second_sketch","staticRenderFns","sketch","p5","uvShader","selector","shape","WIDTH","HEIGHT","type","shapeType","preload","readShader","matrices","Tree","pMatrix","mvMatrix","varyings","texcoords2","setup","canvas","createCanvas","WEBGL","parent","noStroke","shader","textureMode","NORMAL","createSelect","position","option","selected","changed","item","value","setUniform","draw","background","quad","circle","triangle","brightnessShader","img","grey_scale","loadImage","createCheckbox","style","input","checked","name","components","SketchP5","stroke","grid","antialiasing","component"],"sourceRoot":""}