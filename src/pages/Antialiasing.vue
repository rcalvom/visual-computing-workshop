<template>
    <b-container class="mt-4">
        <b-row align-content="center" align-h="center" align-v="center">
            <h1 class="mt-4">Anti-aliasing</h1>
        </b-row> 
        <b-row>
            <h2 class="mt-4">Introduction</h2>
        </b-row>
        <b-row align-h="start" align-v="start">
            <p class="text-justify">
                Aliasing in digital signal processing is the overlapping that occurs when processing high resolution signals on low resolution media. This phenomenon has been worked on mainly in the theory of computation and its application is mostly in graphics processing. Antialising consists of all techniques related to avoid or reduce the impact generated by this phenomenon.
            </p>
        </b-row>
        <b-row align-content="center" align-h="center" align-v="center">
            <b-col>
                <b-img thumbnail src="https://www.dataforth.com/g/aliasing-examples.png" class="mt-4"/>
            </b-col>
            <b-col>
                <b-img thumbnail src="https://diit.cz/sites/default/files/styles/large/public/anti_aliasing.png?itok=2ecsdnbt&c=80f32de47ece52d2f4d91285b63428df" class="mt-4"/>
            </b-col>
        </b-row>
        <b-row>
            <h2 class="mt-4">Literature review</h2>
        </b-row>
        <b-row>
            <p>
                In general, this concept was born in the theory of computation where there was a loss of information when one wanted to analyze an analog signal using digital signals.
            </p>
        </b-row>
        <b-row align-content="center" align-h="center" align-v="center">
            <b-col>
                <b-img center thumbnail src="https://people.finearts.uvic.ca/~aschloss/course_mat/MU207/207equations/aliasing.jpg" class="mt-4 text-center"/>
            </b-col>
        </b-row>
        <b-row class="mt-4">
            <p>
                There are applications of anti-aliasing using algorithms on the figures but also using artificial intelligences to predict the points that would help to improve the sampling of the signals.
            </p>
        </b-row>
        <b-row>
            <p>
                In the article "Evaluating Different Spatial Anti Aliasing Techniques" by Victor Kesten, different methods for the implementation of anti-alising are shown, but it is mentioned that the MSAAx4 and FXAA methods are the most optimal for anti-aliasing in 3D contexts on computers with not very good computational capabilities.
            </p>
        </b-row>
        <b-row align-content="center" align-h="center" align-v="center">
            <b-col>
                <b-img center thumbnail src="https://www.softzone.es/app/uploads-softzone.es/2021/05/MSAA-Antialiasing.png" class="mt-4 text-center"/>
            </b-col>
        </b-row>
        <b-row class="mt-4">
            <p>
                This filter is quite useful in practice as it allows to scale it in iterations in order to adjust it to the performance of the system.
            </p>
        </b-row>
        <b-row>
            <h2>Methods</h2>
        </b-row>
        <b-row>
            <p>
                We are going to present an implementation of anti-aliasing using sampling and barycentric coordinates to draw a triangle, here the step by step is as follows
            </p>
            <p>
                <ul>
                    <li>
                        Define the <vue-mathjax formula="$(A_x, A_y), (B_x, B_y), (C_x, C_y)$"/> coordinates of each of the vertices of the triangle to be drawn. The unit of measurement is pixels
                    </li>
                    <li>
                        Now, we calculate the barycentric coordinates of several points inside the pixels, preferably the amount of these samples will be a number squared.
                        <b-img center thumbnail src="https://learnopengl.com/img/advanced/anti_aliasing_rasterization_samples.png" class="mt-4 text-center"/>
                    </li>
                    <li class="mt-4">
                        With the help of the barycentric coordinates, the number of samples of each pixel within the triangle to be drawn is counted. Depending on this value an alpha value will be defined for the corresponding color.
                        <b-img center thumbnail src="https://learnopengl.com/img/advanced/anti_aliasing_rasterization_samples_filled.png" class="my-4 text-center"/>
                        <vue-mathjax class="mt-4" formula="$$\alpha = 256 \times \dfrac{\# \text{of samples in the pixel and in the triangle}}{\# \text{of total samples in a pixel}}$$"/>
                    </li>
                </ul>
            </p>
        </b-row>
        <b-row>
            <h2>Code and Results</h2>
        </b-row>
        <b-row>
            <b-col cols="12" class="mb-4">
                <SketchP5 :sketch="sketch" class="mt-4" :width="960" :heigth="640"/>
            </b-col>
            <b-col cols="2" offset="2">
                <b-row class="m-2">
                    <label for="input-field-0x">Punto 1 X</label>
                    <b-form-input size="sm" id="input-field-0x" type="number" min="1" max="96" value="5"/>
                </b-row>
                <b-row class="m-2">
                    <label for="input-field-1x">Punto 2 X</label>
                    <b-form-input size="sm" id="input-field-1x" type="number" min="1" max="96" value="25"/>
                </b-row>
                <b-row class="m-2">
                    <label for="input-field-2x">Punto 3 X</label>
                    <b-form-input size="sm" id="input-field-2x" type="number" min="1" max="96" value="25"/>
                </b-row>
            </b-col>
            <b-col cols="2" >
               <b-row class="m-2">
                   <label for="input-field-0y">Punto 1 Y</label>
                    <b-form-input size="sm" id="input-field-0y" type="number" min="1" max="64" value="22"/>
                </b-row>
                <b-row class="m-2">
                    <label for="input-field-1y">Punto 2 Y</label>
                    <b-form-input size="sm" id="input-field-1y" type="number" min="1" max="64" value="5"/>
                </b-row>
                <b-row class="m-2">
                    <label for="input-field-2y">Punto 3 Y</label>
                    <b-form-input size="sm" id="input-field-2y" type="number" min="1" max="64" value="30"/>
                </b-row>
            </b-col>
            <b-col cols="2">
                <b-row class="m-2">
                    <label for="input-field-cols">Columnas</label>
                    <b-form-input size="sm" id="input-field-cols" type="number" min="1" max="96" value="48"/>
                </b-row>
                <b-row class="m-2">
                   <b-form-checkbox button-variant="primary" id="input-field-antialiasing" switch v-model="antialiasing">
                        Anti-aliasing
                    </b-form-checkbox>
                </b-row>
                <b-row class="m-2">
                   <b-form-checkbox button-variant="primary" id="input-field-grid" switch v-model="grid">
                        Grid
                    </b-form-checkbox>
                </b-row>
            </b-col>
            <b-col cols="2" >
               <b-row class="m-2">
                   <label for="input-field-rows">Filas</label>
                    <b-form-input size="sm" id="input-field-rows" type="number" min="1" max="64" value="32"/>
                </b-row>
                <b-row class="m-2">
                   <b-form-checkbox button-variant="primary" id="input-field-stroke" switch v-model="stroke">
                        Stroke
                    </b-form-checkbox>
                </b-row>
                <b-row class="m-2">
                   <label for="input-field-step">Step</label>
                    <b-form-input size="sm" id="input-field-step" type="number" min="1" max="5" value="3"/>
                </b-row>
            </b-col>
        </b-row>
        <div class="mt-4">
            <code-highlight language="javascript">
                <pre>
                    /**
                    * Application of Scanimation visual illusion using p5.js
                    * @param {p5} p5 reference 
                    */

                    const sketch = (p5) => {
                        const WIDTH = 960;
                        const HEIGTH = 640;

                        let rows = 32; // max 64
                        let cols = 48; // max 96
                        
                        let length = 10;

                        let step = 4;
                        let stroke = true;
                        let antialiasing = true;
                        let grid = true;

                        let quadrille;
                        let colsInput;
                        let rowsInput;

                        let vertex0X = 4;
                        let vertex0Y = 21;
                        let vertex1X = 23;
                        let vertex1Y = 4;
                        let vertex2X = 24;
                        let vertex2Y = 29;
                        
                        p5.setup = () => {
                            var canvas = p5.createCanvas(WIDTH, HEIGTH);
                            canvas.parent("vue-canvas");

                            p5.background('#060621');
                            quadrille = p5.createQuadrille(cols, rows);

                            colsInput = p5.select("#input-field-cols");
                            colsInput.input(sizeInputEvent);

                            rowsInput = p5.select("#input-field-rows");
                            rowsInput.input(sizeInputEvent);

                            p5.select("#input-field-stroke").changed(() => {
                                stroke = !stroke;
                                update();
                            });

                            p5.select("#input-field-antialiasing").changed(() => {
                                antialiasing = !antialiasing;
                                update();
                            });

                            p5.select("#input-field-grid").changed(() => {
                                grid = !grid;
                                update();
                            });

                            p5.select("#input-field-0x").input(vertexInputEvent);
                            p5.select("#input-field-1x").input(vertexInputEvent);
                            p5.select("#input-field-2x").input(vertexInputEvent);
                            p5.select("#input-field-0y").input(vertexInputEvent);
                            p5.select("#input-field-1y").input(vertexInputEvent);
                            p5.select("#input-field-2y").input(vertexInputEvent);

                            p5.select("#input-field-step").input((e) => {
                                step = parseInt(e.target.value);
                                update();
                            });

                            p5.stroke('white');
                            p5.strokeWeight(1);
                            p5.noFill();

                            update();

                            

                        }

                        const sizeInputEvent = (e) => {
                            if(e.target.id == "input-field-cols"){
                                cols = parseInt(e.target.value);
                            }else if(e.target.id == "input-field-rows"){
                                rows = parseInt(e.target.value);
                            }
                            update();
                            
                        }

                        const vertexInputEvent = (e) => {
                            if(e.target.id == "input-field-0x"){
                                vertex0X = parseInt(e.target.value) - 1;
                            }else if(e.target.id == "input-field-1x"){
                                vertex1X = parseInt(e.target.value) - 1;
                            }else if(e.target.id == "input-field-2x"){
                                vertex2X = parseInt(e.target.value) - 1;
                            }else if(e.target.id == "input-field-0y"){
                                vertex0Y = parseInt(e.target.value) - 1;
                            }else if(e.target.id == "input-field-1y"){
                                vertex1Y = parseInt(e.target.value) - 1;
                            }else if(e.target.id == "input-field-2y"){
                                vertex2Y = parseInt(e.target.value) - 1;
                            }
                            
                            update();
                        }

                        function update(){
                            p5.background('#060621');
                            quadrille = p5.createQuadrille(cols, rows);
                            length = (WIDTH / cols * rows > HEIGTH) ? HEIGTH / rows : WIDTH / cols;
                            for(var i = 0; i &lt; rows; i++){
                                for(var j = 0; j &lt; cols; j++){
                                    quadrille._memory2D[i][j] = p5.color([0, 0, 255, 0]);
                                }
                            }
                            var step_aux;
                            if(antialiasing){
                                step_aux = step;
                            }else{
                                step_aux = 2;
                            }
                            var borderx = 0;
                            for(i = 0; i &lt; rows; i+=1/step_aux){
                                var bordery = 0;
                                if(borderx++ % step_aux == 0){
                                    continue
                                }
                                for(j = 0; j &lt; cols; j+=1/step_aux){
                                    if(bordery++ % step_aux == 0){
                                        continue;
                                    }
                                    if(grid){
                                        p5.point(j * length, i * length);
                                    }
                                    var coords = quadrille._barycentric_coords(i, j, vertex0Y, vertex0X, vertex1Y, vertex1X, vertex2Y, vertex2X);
                                    if (coords.w0 >= 0 && coords.w1 >= 0 && coords.w2 >= 0) {
                                        quadrille._memory2D[Math.trunc(i)][Math.trunc(j)] = p5.color([0, 0, 255, p5.alpha(quadrille._memory2D[Math.trunc(i)][Math.trunc(j)]) + Math.trunc(256/Math.pow(step_aux - 1, 2))]);
                                    }
                                }
                            }
                            if(grid){
                                p5.drawQuadrille(quadrille, { cellLength: length, outline: 'grey', outlineWeight: 1, board: true});
                            }else{
                                p5.drawQuadrille(quadrille, { cellLength: length, outline: 'grey', outlineWeight: 0, board: true});
                            }
                            if(stroke){
                                p5.triangle(vertex0X * length, vertex0Y * length, vertex1X * length, vertex1Y * length, vertex2X * length, vertex2Y * length);
                            }
                            
                        }
                    
                    }
                    
                    export default sketch;
  
  
                </pre>
            </code-highlight>
        </div>
        <b-row>
            <h2>Discussion</h2>
        </b-row>
        <b-row>
            <p>
                For discussion of this article I propose two points
                <ul>
                    <li>
                        Are we actually reducing information loss? Or are we actually adding false information that appears to be the real thing?
                    </li>
                    <li>
                        This implementation using centrobar coordinates is very efficient when we want to draw n-simplexes (triangles, tetrahedra, etc) but how could we do it to draw figures that are not triangles?
                    </li>
                </ul>
            </p>
        </b-row>
        <b-row>
            <h2>Conclusion</h2>
            <p>
                <ul>
                    <li>
                        The barycentric coordinates are very useful in this method of anti.aliasing, where we smooth the loss of information in triangles.
                    </li>
                    <li>
                        Anti-aliasing will not be very useful when we want to represent figures in high resolution media since the loss of information will be very low.
                    </li>
                    <li>
                        The use of this technique in some cases will greatly improve the user experience.
                    </li>
                    <li>
                        Anti-aliasing is a process that should be used with care as it is adding load to the graphics processing.
                    </li>
                </ul>
            </p>
        </b-row>
        <b-row>
            
        </b-row>
    </b-container>
</template>

<script>
    import antialiasing from '../sketches/antialiasing.p5';
    import SketchP5 from '../components/SketchP5.vue';

    import CodeHighlight from "vue-code-highlight/src/CodeHighlight.vue";
    import "vue-code-highlight/themes/duotone-sea.css";
    import "vue-code-highlight/themes/window.css";
    import { VueMathjax } from 'vue-mathjax';

    export default {
        name: "VisualIllusion",
        components: {
            SketchP5,
            CodeHighlight,
            'vue-mathjax': VueMathjax
        },
        data(){
            return {
                stroke: true,
                grid: true,
                antialiasing: true,
                sketch: antialiasing
            }
        },
        created(){  
            
        }
    };
</script>

<style scoped>
    p, li {
        font-size: 1.25rem;
    }    
    h1 {
        font-size: 4rem;
    }
</style>